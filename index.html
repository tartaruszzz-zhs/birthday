<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Universe For You</title>
    <!-- 引入高级字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&family=Noto+Serif+SC:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body, html { 
            width: 100%; height: 100%; overflow: hidden; 
            background-color: #03030a !important; 
            font-family: 'Noto Serif SC', serif; color: #fff; 
        }
        canvas { display: block; }
        #text-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; transition: opacity 1.5s; }
        #click-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; cursor: pointer; display: flex; flex-direction: column; justify-content: flex-end; align-items: center; padding-bottom: 50px; }
        .hint-text { font-size: 0.9rem; letter-spacing: 4px; color: rgba(255,255,255,0.4); animation: breathe 2s infinite ease-in-out; }
        
        /* 礼物卡片样式 */
        #main-content { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -45%); 
            width: 90%; max-width: 600px; max-height: 90vh; overflow-y: auto; 
            z-index: 5; opacity: 0; pointer-events: none; 
            transition: all 2s cubic-bezier(0.16, 1, 0.3, 1); 
            background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.1); 
            border-radius: 24px; padding: 40px; backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
        }
        .content-active { opacity: 1 !important; transform: translate(-50%, -50%) !important; pointer-events: auto !important; }
        .title-en { font-family: 'Cinzel', serif; font-size: 2.2rem; text-align: center; margin-bottom: 5px; background: linear-gradient(120deg, #fff, #a0b0d0); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .title-cn { text-align: center; font-size: 0.9rem; color: rgba(255,255,255,0.6); letter-spacing: 4px; margin-bottom: 30px; }
        .media-frame { width: 100%; border-radius: 12px; overflow: hidden; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .media-frame img { width: 100%; display: block; filter: brightness(0.9); }
        .poetry { font-size: 1rem; line-height: 2; color: rgba(255,255,255,0.85); text-align: justify; }
        .poetry p { margin-bottom: 1.2rem; }
        .signature { text-align: right; margin-top: 30px; font-family: 'Cinzel', serif; color: rgba(255,255,255,0.4); font-size: 0.8rem; }
        
        @keyframes breathe { 0%, 100% { opacity: 0.2; transform: translateY(0); } 50% { opacity: 0.7; transform: translateY(-5px); } }
    </style>
</head>
<body>
    <canvas id="text-canvas"></canvas>
    <div id="click-layer"><div class="hint-text" id="hint">点 击 屏 幕，启 动 宇 宙</div></div>
    
    <div id="main-content">
        <h1 class="title-en">Happy Birthday</h1>
        <div class="title-cn">致 独一无二的你</div>
        <div class="media-frame">
            <img src="https://images.unsplash.com/photo-1493246507139-91e8fad9978e?q=80&w=1200&auto=format&fit=crop" alt="Birthday Memory">
        </div>
        <div class="poetry">
            <p>有人说，宇宙中的每一个原子，都曾是一颗恒星的心脏。</p>
            <p>宇宙很大，但很高兴我们的坐标在过去的一年里重合过很多次。那些一起讨论过的题目、聊过的天，是很值得开心和收藏的记忆。</p>
            <p>今天是你来到这颗星球的第20年。</p>
            <p>愿你未来的每一天都像今天一样，有星光，有期待，也有随时可以分享快乐的朋友。生日快乐。</p>
            <div class="signature">2026.02</div>
        </div>
    </div>

    <!-- 背景音乐 -->
    <audio id="bgm" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" loop></audio>

    <script>
        const canvas = document.getElementById('text-canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // 优化渲染性能
        let width, height;
        let particles = [];
        const phrases = ["希望美丽", "善良可爱", "的肖语欣", "永远开心", "快乐相伴"];
        let clickCount = 0;

        // 移动端检测并设置粒子数
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (navigator.userAgentData && navigator.userAgentData.mobile);
        const PARTICLE_COUNT = isMobile ? 2000 : 4500;

        // 粒子系统配置
        const CONFIG = {
            particleCount: PARTICLE_COUNT, // 根据设备动态调整
            step: 3,             // 采样步长，越小细节越丰富（横笔画清晰的关键）
            friction: 0.86,      // 摩擦力
            spring: 0.04         // 弹力
        };

        class Particle {
            constructor() {
                this.init();
            }
            init() {
                this.x = Math.random() * (window.innerWidth || 1000);
                this.y = Math.random() * (window.innerHeight || 800);
                this.tx = this.x; 
                this.ty = this.y;
                this.vx = 0; 
                this.vy = 0;
                this.wanderVx = (Math.random() - 0.5) * 0.5;
                this.wanderVy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 1.0 + 0.4; // 微小粒子更显高级
                this.mode = 'wander';
                this.alpha = Math.random() * 0.4 + 0.1;
            }
            update() {
                if (this.mode === 'wander') {
                    this.x += this.wanderVx;
                    this.y += this.wanderVy;
                    if (this.x < 0 || this.x > width) this.wanderVx *= -1;
                    if (this.y < 0 || this.y > height) this.wanderVy *= -1;
                } else {
                    let dx = this.tx - this.x;
                    let dy = this.ty - this.y;
                    this.vx += dx * CONFIG.spring;
                    this.vy += dy * CONFIG.spring;
                    this.vx *= CONFIG.friction;
                    this.vy *= CONFIG.friction;
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.mode === 'target' ? 0.85 : this.alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function setup() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            particles = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function getPixels(text) {
            const tmp = document.createElement('canvas');
            const tctx = tmp.getContext('2d');
            tmp.width = width;
            tmp.height = height;
            
            // 使用加粗字体并增大字号以获取更多像素点
            let fSize = Math.min(width * 0.22, 160);
            tctx.font = `900 ${fSize}px 'Noto Serif SC', serif`;
            tctx.textAlign = 'center';
            tctx.textBaseline = 'middle';
            tctx.fillText(text, width / 2, height / 2);
            
            const data = tctx.getImageData(0, 0, width, height).data;
            const res = [];
            
            // 步长设为 3，采样密度大幅增加
            for (let y = 0; y < height; y += CONFIG.step) {
                for (let x = 0; x < width; x += CONFIG.step) {
                    if (data[(y * width + x) * 4 + 3] > 100) { // 降低阈值，捕捉边缘
                        res.push({x, y});
                    }
                }
            }
            // 随机化数组，让粒子聚拢时轨迹更自然
            return res.sort(() => Math.random() - 0.5);
        }

        function transform(text) {
            const targets = getPixels(text);
            
            // 如果采样出的像素点超过当前粒子数，动态增加粒子
            if (particles.length < targets.length) {
                const diff = targets.length - particles.length;
                for(let i=0; i<diff; i++) particles.push(new Particle());
            }

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                if (i < targets.length) {
                    p.mode = 'target';
                    p.tx = targets[i].x;
                    p.ty = targets[i].y;
                    // 给一个初始扰动
                    p.vx += (Math.random() - 0.5) * 40;
                    p.vy += (Math.random() - 0.5) * 40;
                } else {
                    // 多余的粒子继续游荡，但稍微向中心靠拢避免看起来太散
                    p.mode = 'wander';
                }
            }
        }

        function render() {
            // 使用极低透明度的黑色覆盖，形成柔和的粒子拖尾
            ctx.fillStyle = '#03030a';
            ctx.fillRect(0, 0, width, height);
            
            for(let i=0; i<particles.length; i++) {
                particles[i].update();
                particles[i].draw();
            }
            requestAnimationFrame(render);
        }

        // 初始化
        setup();
        render();

        window.addEventListener('resize', () => {
            if(clickCount === 0) setup();
        });

        // 交互逻辑
        document.getElementById('click-layer').onclick = function() {
            const bgm = document.getElementById('bgm');
            if (clickCount === 0) {
                bgm.play().catch(() => {});
                document.getElementById('hint').innerText = "继 续 点 击 ...";
            }
            
            if (clickCount < phrases.length) {
                transform(phrases[clickCount]);
                clickCount++;
            } else {
                // 结束动画
                this.style.display = 'none';
                particles.forEach(p => {
                    p.mode = 'target';
                    p.tx = p.x + (Math.random()-0.5) * 3000;
                    p.ty = p.y + (Math.random()-0.5) * 3000;
                    p.vx = (Math.random()-0.5) * 100;
                    p.vy = (Math.random()-0.5) * 100;
                });
                setTimeout(() => {
                    canvas.style.opacity = '0';
                    document.getElementById('main-content').classList.add('content-active');
                }, 800);
            }
        };
    </script>
</body>
</html>